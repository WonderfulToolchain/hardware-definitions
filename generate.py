#!/usr/bin/python

from pathlib import Path
from xml.dom import minidom, Node
import argparse
import datetime
import glob
import re

argparser = argparse.ArgumentParser(prog="generate", description="Convert hardware definition XMLs into header files.")
argparser.add_argument("input", help="input directory containing definition XMLs")
argparser.add_argument("-o", "--output", required=True, help="output header/include file name")
argparser.add_argument("-f", "--format", required=True, choices=["c", "nasm"], help="output file format")
argparser.add_argument("-v", "--verbose", action="store_true")
argparser.add_argument("--define-guard", help="#define guard name")

args = argparser.parse_args()

# XML helpers

def hex_0x(value):
    return "0x%0.2X" % value

def attr_value(node, a, defv=None):
    if node.nodeType == Node.ELEMENT_NODE:
        if a in node.attributes:
            return node.attributes[a].nodeValue
    return defv

def inner_text(xml):
    t = ""
    for node in xml.childNodes:
        if node.nodeType == Node.TEXT_NODE:
            t += node.nodeValue
        elif node.nodeType == Node.ELEMENT_NODE:
            t += inner_text(node)
    return t

def comment_to_lines(xml, prefix=''):
    result = [x.strip() for x in inner_text(xml).splitlines()]
    if len(result) > 0 and len(prefix) > 0:
        result[0] = prefix + result[0]
    return result

# Parsing code

def get_comment_lines(f):
    for node in f.childNodes:
        if node.nodeType != Node.ELEMENT_NODE:
            continue
        if node.nodeName == "comment":
            return comment_to_lines(node)

    return []

def write_doxygen_comment(lines, output_file):
    if len(lines) > 0:
        output_file.write("/**\n")
        for line in lines:
            output_file.write(f" * {line}\n")
        output_file.write(" */\n")

# Code emitters

class NullEmitter:
    def __init__(self, outf, languages=[]):
        self.outf = outf
        self.languages = languages

    def emit_section_start(self, name, comment):
        pass

    def emit_section_end(self, name):
        pass

    def emit_code(self, language, code):
        if language in self.languages:
            self.outf.write(code)
            self.outf.write("\n")

    def emit_value(self, name, value, comment=[], hex=False):
        pass

    def emit_address(self, name, value, width, comment=[]):
        return self.emit_value(name, value, comment, hex=True)

    def emit_address_array(self, name, value, count, width, pitch, comment=[]):
        return self.emit_value(name, value, comment, hex=True)

    def emit_newline(self):
        self.outf.write("\n")

class CEmitter(NullEmitter):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs, languages=["c"])

        t = datetime.datetime.now()
        self.outf.write(f"// SPDX-License-Identifier: CC0-1.0\n")
        self.outf.write(f"//\n")
        self.outf.write(f"// Auto-generated by hardware-definitions/generate.py on {t.strftime('%Y-%m-%d %H:%M')}\n")
        self.outf.write(f"#ifndef __ASSEMBLER__\n#include <stdint.h>\n#endif\n")

    def get_type(self, width):
        type = "void"
        if width == 1:
            type = "uint8_t"
        elif width == 2:
            type = "uint16_t"
        elif width == 4:
            type = "uint32_t"
        elif width == 8:
            type = "uint64_t"
        return type

    def emit_section_start(self, name, comment):
        if len(comment) == 0:
            comment.append("")
        comment[0] = f"@addtogroup hardware_{name} Hardware defines - {comment[0]}"
        comment.append("@{")
        self.outf.write("\n")
        write_doxygen_comment(comment, outf)

    def emit_section_end(self, name):
        self.outf.write("\n/**@}*/\n")

    def emit_value(self, name, value, comment=[], hex=False):
        if hex:
            value = hex_0x(value)
        write_doxygen_comment(comment, outf)
        self.outf.write(f"#define {name} {value}\n")

    def emit_address(self, name, value, width, comment=[]):
        type = self.get_type(width)
        value = hex_0x(value)
        write_doxygen_comment(comment, outf)
        self.outf.write(f"#define {name} (*((volatile {type}*) {value}))\n")

    def emit_address_array(self, name, value, count, width, pitch, comment=[]):
        type = self.get_type(width)
        value = hex_0x(value)
        write_doxygen_comment(comment, outf)
        if width == pitch:
            self.outf.write(f"#define {name} (*((volatile {type}(*)[{count}]) {value}))\n")
        else:
            self.outf.write(f"#define {name}(x) (*((volatile {type}*) (({value}) + ({pitch} * (x)))))\n")

class NASMEmitter(NullEmitter):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs, languages=["nasm"])

        t = datetime.datetime.now()
        self.outf.write(f"; SPDX-License-Identifier: CC0-1.0\n")
        self.outf.write(f";\n")
        self.outf.write(f"; Auto-generated by hardware-definitions/generate.py on {t.strftime('%Y-%m-%d %H:%M')}\n")

    def emit_section_start(self, name, comment):
        for l in comment:
            self.outf.write(f"; {l}\n")

    def emit_section_end(self, name):
        self.emit_newline()

    def emit_value(self, name, value, comment=[], hex=False):
        if hex:
            value = hex_0x(value)
        for l in comment:
            self.outf.write(f"; {l}\n")
        self.outf.write(f"{name} equ {value}\n")

# Processing code

def process_macro_tree(em, f, name, state):
    # Append current element name
    local_name = attr_value(f, "name", "")
    if len(local_name) > 0:
        if len(name) > 0:
            name += "_"
        name += local_name

    # Process self
    if f.nodeName == "port":
        em.emit_newline()
        em.emit_value(f"{name}_PORT", int(attr_value(f, "address"), 0), get_comment_lines(f), hex=True)
    elif f.nodeName == "address":
        width = int(attr_value(f, "width"), 0)
        em.emit_newline()
        em.emit_address(name, int(attr_value(f, "value"), 0), width, get_comment_lines(f))
    elif f.nodeName == "addressarray":
        count = int(attr_value(f, "count"), 0)
        width = int(attr_value(f, "width"), 0)
        pitch = width
        if "pitch" in f.attributes:
            pitch = int(attr_value(f, "pitch"), 0)
        em.emit_newline()
        em.emit_address_array(name, int(attr_value(f, "value"), 0), count, width, pitch, get_comment_lines(f))
    elif f.nodeName == "portarray":
        comment = get_comment_lines(f)
        address = int(attr_value(f, "address"), 0)
        start = int(attr_value(f, "start", "0"), 0)
        count = int(attr_value(f, "count"), 0)
        width = int(attr_value(f, "width"), 0)

        em.emit_newline()
        for i in range(0, count):
           em.emit_value(f"{name}_{i + start}_PORT", address + width * i, comment, hex=True)

        em.emit_code("c", f"#define {name}_PORT(i) ({hex_0x(address)} + ({width} * ((i) - {start})))")
    elif f.nodeName == "enum":
        state["offset"] += int(attr_value(f, "offset"), 0)
    elif f.nodeName == "code":
         em.emit_code(attr_value(f, "language"), inner_text(f))

    # Process children
    for node in f.childNodes:
        if node.nodeType != Node.ELEMENT_NODE:
            continue
        process_macro_tree(em, node, name, state.copy())

    # Process self
    if len(local_name) > 0:
        if f.nodeName == "bit":
            em.emit_value(name, 1 << int(attr_value(f, "offset"), 0), get_comment_lines(f), hex=True)
        elif f.nodeName == "enum":
            offset = state["offset"]
            width = int(attr_value(f, "width"), 0)
            em.emit_value(f"{name}_SHIFT", offset, get_comment_lines(f))
            em.emit_value(f"{name}_MASK", ((1 << width) - 1) << offset, hex=True)
        elif f.nodeName == "value":
            offset = state["offset"]
            em.emit_value(name, int(attr_value(f, "value"), 0) << offset, get_comment_lines(f), hex=True)

def process_file(em, f, name):
    em.emit_section_start(name, get_comment_lines(f.documentElement))
    process_macro_tree(em, f.documentElement, "", {
        "offset": 0
    })
    em.emit_section_end(name)

Path(args.output).parent.mkdir(parents=True, exist_ok=True)
with open(args.output, "w") as outf:
    emitter = None
    if args.format == "c":
        emitter = CEmitter(outf)
    elif args.format == "nasm":
        emitter = NASMEmitter(outf)

    if args.define_guard:
        emitter.emit_code("c", f"\n#ifndef {args.define_guard}\n#define {args.define_guard}")

    for fn in sorted(glob.glob("**/*.xml", root_dir=args.input, recursive=True)):
        print(f"Parsing {fn}...")
        input_fn = Path(args.input) / fn
        input_xml = minidom.parse(str(input_fn))    
        process_file(emitter, input_xml, fn.replace(".xml", "").replace("/", "_"))

    if args.define_guard:
        emitter.emit_code("c", f"\n#endif /* {args.define_guard} */\n")
